Nauka programowania w Javie (i nie tylko) obejmuje nie tylko zrozumienie składni i pojęć, ale także zdobywanie praktycznego doświadczenia poprzez ćwiczenia kodowania. W tym artykule przedstawiamy zestaw 25 podstawowych ćwiczeń kodowania w Javie wraz z ich rozwiązaniami. Ćwiczenia te obejmują różne podstawowe koncepcje programowania, zapewniając kompleksową podstawę dla początkujących i świetne źródło ćwiczeń dla tych, którzy chcą poprawić swoje umiejętności Java. C# i innych językach. Wystarczy odtworzyć te same funkcjonalności w kazdym z tych języków.

# 1. Hello World

Napisz program Java, aby wydrukować "Hello, World!" Do konsoli.

```java
// Słowo kluczowe 'public' wskazuje, że klasa jest dostępna z każdej innej klasy.

// Nazwa klasy to HelloWorld, a plik powinien mieć nazwę HelloWorld.java.
public class HelloWorld {

// Metoda main jest punkt wejścia programu.
// Jest wywoływana, gdy program jest uruchomiony.
    public static void main(String[] args) {
        
// System.out to obiekt, który reprezentuje standardowy strumień wyjściowy.
// println() to metoda używana do drukowania wiersza tekstu w konsoli.
        System.out.println("Hello, World!");
    }
}
```

Oto zestawienie głównych elementów:

## Class Declaration

- `public class HelloWorld`: Declares a class named `HelloWorld`.
- `public` keyword allows the class to be accessed from other classes.

## Main Method

- `public static void main(String[] args)`: This is the main method, which serves as the entry point for the program.
- `public`: The main method must be declared as public so that it can be accessed by the Java runtime system.
- `static`: The method is associated with the class rather than with any specific instance of the class.
- `void`: The main method does not return any value.
- `main`: The name of the method. The Java runtime system looks for this specific method signature to start the program.
- `String[] args`: The main method takes an array of strings as parameters. This allows  the program to accept command-line arguments, although in this case, the program does not use them.

## Print Statement

- `System.out.println("Hello, World!");`: This line prints the text "Hello, World!" followed by a newline to the standard output (usually the console).

## Odpowiednik w c#

```c#
class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine("Hello, World!");
    }
}
```

W nowej wersji 

```swift
Console.WriteLine("Hello, World!");
```

## Odpowiednik Python

```swift

```



# 2. Sum of Two Numbers

Write a Java program that takes two numbers as input and prints their sum.

```java
import java.util.Scanner;

public class SumOfTwoNumbers {
    public static void main(String[] args) {
        // Create a Scanner object to read input from the console.
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter the first number.
        System.out.print("Enter the first number: ");
        
        // Read the first number entered by the user.
        int num1 = scanner.nextInt();

        // Prompt the user to enter the second number.
        System.out.print("Enter the second number: ");
        
        // Read the second number entered by the user.
        int num2 = scanner.nextInt();

        // Calculate the sum of the two numbers.
        int sum = num1 + num2;

        // Print the result (sum) to the console.
        System.out.println("Sum: " + sum);
    }
}
```

Here’s a step-by-step explanation:

## Import Statement

- `import java.util.Scanner;`: This imports the `Scanner` class from the `java.util` package. The `Scanner` class is used for reading user input.

## Class Declaration

- `public class SumOfTwoNumbers`: Declares a class named `SumOfTwoNumbers`.

## Main Method

- `public static void main(String[] args)`: This is the main method, the entry point of the program.

## Scanner Initialization

- `Scanner scanner = new Scanner(System.in);`: Creates a `Scanner` object named `scanner` to read input from the console (`System.in`).

## User Input

- `System.out.print("Enter the first number: ");`: Prints a prompt asking the user to enter the first number.
- `int num1 = scanner.nextInt();`: Reads the first integer entered by the user using the `nextInt()` method of the `Scanner` class.
- `System.out.print("Enter the second number: ");`: Prints a prompt asking the user to enter the second number.
- `int num2 = scanner.nextInt();`: Reads the second integer entered by the user.

## Sum Calculation

- `int sum = num1 + num2;`: Calculates the sum of the two numbers.

## Print Result

- `System.out.println("Sum: " + sum);`: Prints the result (sum) to the console.

Odpowiednik c#

```swift
class Program
{
    static void Main(string[] args)
    {

        // Prompt the user to enter the first number.
        Console.Write("Enter the first number: ");

        // Read the first number entered by the user.
        int num1 = Convert.ToInt32(Console.ReadLine());

        // Prompt the user to enter the second number.
        Console.Write("Enter the second number: ");

        // Read the second number entered by the user.
        int num2 = Convert.ToInt32(Console.ReadLine());

        // Calculate the sum of the two numbers.
        int sum = num1 + num2;

        // Print the result (sum) to the console.
        Console.WriteLine("Sum: " + sum);
    }
}
```

Bardziej elegancka wersja

```csharp
class Program
{
    static void Main(string[] args)
    {
        double num1 = 0;
        double num2 = 0;
        while (true)
        {


            // Prompt the user to enter the first number.
            Console.Write("Enter the first number: ");

            // Read the first number entered by the user.
            var num1Text = Console.ReadLine();
            // int num1 = Convert.ToInt32(num1Text);
           
           if (double.TryParse(num1Text, out num1))
            {
                break;
            } else
            {
                Console.WriteLine("Bądz człowiekiem podaj liczbę");
            }
        }

        while (true)
        {



            // Prompt the user to enter the second number.
            Console.Write("Enter the second number: ");

            // Read the second number entered by the user.
            var num2Text = Console.ReadLine();
            //int num2 = Convert.ToInt32(Console.ReadLine());
           if (double.TryParse(num2Text, out num2))
            {
                break ;
            } else
            {
                Console.WriteLine("Bądz człowkiemiem podaj liczbę");
            }

            
        }
        // Calculate the sum of the two numbers.
        var sum = num1 + num2;

        // Print the result (sum) to the console.
        Console.WriteLine("Sum: " + sum);
    }
}
```











Odpowiednik Swift

```swift
import Foundation

func readIntFromConsole(prompt: String) -> Int {
    print(prompt, terminator: "")
    guard let input = readLine(), let number = Int(input) else {
        fatalError("Invalid input. Please enter a valid integer.")
    }
    return number
}

func main() {
    let num1 = readIntFromConsole(prompt: "Enter the first number: ")
    let num2 = readIntFromConsole(prompt: "Enter the second number: ")

    let sum = num1 + num2
    print (sum)
}

main()
```



# 3. Check Even or Odd

Write a Java program to check if a given number is even or odd.

```java
import java.util.Scanner;

public class EvenOrOdd {
    public static void main(String[] args) {
        // Create a Scanner object to read input from the console.
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter a number.
        System.out.print("Enter a number: ");
        
        // Read the number entered by the user.
        int num = scanner.nextInt();

        // Check if the number is even or odd using the modulo operator (%).
        if (num % 2 == 0) {
            // If the remainder when divided by 2 is 0, the number is even.
            System.out.println(num + " is even.");
        } else {
            // If the remainder when divided by 2 is not 0, the number is odd.
            System.out.println(num + " is odd.");
        }
    }
}
```

Here’s a step-by-step explanation:

## Import Statement

- `import java.util.Scanner;`: This imports the `Scanner` class from the `java.util` package.

## Class Declaration

- `public class EvenOrOdd`: Declares a class named `EvenOrOdd`.

## Main Method

- `public static void main(String[] args)`: This is the main method, the entry point of the program.

## Scanner Initialization

- `Scanner scanner = new Scanner(System.in);`: Creates a `Scanner` object named `scanner` to read input from the console (`System.in`).

## User Input

- `System.out.print("Enter a number: ");`: Prints a prompt asking the user to enter a number.
- `int num = scanner.nextInt();`: Reads the integer entered by the user.

## Even or Odd Check

- `if (num % 2 == 0) {`: Checks if the entered number is even by using the modulo operator (%). If the remainder is 0, the number is even.
- `System.out.println(num + " is even.");`: Prints a message indicating that the number is even.
- `} else {`: If the remainder is not 0, the number is odd.
- `System.out.println(num + " is odd.");`: Prints a message indicating that the number is odd.

Wersja c#

```csharp
class Program
{
    static void Main(string[] args)
    {
        int num1 = 0;
        while (true)
        {


            // Prompt the user to enter the first number.
            Console.Write("Podaj liczbę całkowitą: ");

            // Read the first number entered by the user.
            var num1Text = Console.ReadLine();
            // int num1 = Convert.ToInt32(num1Text);
           
           if (int.TryParse(num1Text, out num1))
            {
                break;
            } else
            {
                Console.WriteLine("Bądz człowiekiem podaj liczbę całkowitą");
            }
            
        }
        if (num1 % 2 == 0)
        {
            Console.WriteLine("Wprowadziłeś liczbę parzystą");
        }
        else
        {
            Console.WriteLine("Wprowdziłeś liczbę nieparzystą");
        }


    }
}
```











# 4. Reverse a String

Write a Java program to reverse a given string.

ada goła im śmiało gada

wół utył i ma miły tułów

ikar bada braki

radar kajak sedes

```java
import java.util.Scanner;

public class ReverseString {
    public static void main(String[] args) {
        // Create a Scanner object to read input from the console.
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter a string.
        System.out.print("Enter a string: ");
        
        // Read the entire line of input entered by the user.
        String input = scanner.nextLine();

        // Create a StringBuilder object and reverse the input string.
        String reversed = new StringBuilder(input).reverse().toString();

        // Print the reversed string to the console.
        System.out.println("Reversed string: " + reversed);
    }
}
```

Here’s a step-by-step explanation:

## Import Statement

- `import java.util.Scanner;`: This imports the `Scanner` class from the `java.util` package. The `Scanner` class is used for reading user input.

## Class Declaration

- `public class ReverseString`: Declares a class named `ReverseString`.

## Main Method

- `public static void main(String[] args)`: This is the main method, the entry point of the program.

## Scanner Initialization

- `Scanner scanner = new Scanner(System.in);`: Creates a `Scanner` object named `scanner` to read input from the console (`System.in`).

## User Input

- `System.out.print("Enter a string: ");`: Prints a prompt asking the user to enter a string.
- `String input = scanner.nextLine();`: Reads the entire line of input entered by the user using the `nextLine()` method of the `Scanner` class.

## String Reversal

- `String reversed = new StringBuilder(input).reverse().toString();`: Uses a `StringBuilder` to reverse the order of characters in the input string. The `reverse()` method reverses the characters, and `toString()` converts the `StringBuilder` back to a `String`.

## Print Result

- `System.out.println("Reversed string: " + reversed);`: Prints the reversed string to the console.



Wersja w c#

```csharp
class Reverse
{
    static void Main()
    {
        // Wyświetlamy tekst co oczekujemy od użytkownika
        Console.Write("Podaj tekst: ");
        // Pobieranie zmiennej do odwrócenia
        string input = Console.ReadLine(); 

        // Inicjalizacja obiektu StringBuilder 
        StringBuilder reversedBuilder = new StringBuilder(input.Length);

        // Odwracanie łańcucha znaków 
        for (int i = input.Length - 1; i >= 0; i--)
        {
            reversedBuilder.Append(input[i]);
        }

        // Konwersja z StringBuilder na string
        string reversedString = reversedBuilder.ToString();

        // Wyświetlenie odwróconego łańcucha
        Console.WriteLine("Odwrócony łańcuch: " + reversedString);
    }
}
```

















# 5. Factorial Calculation

Write a Java program to calculate the factorial of a given number.

```java
import java.util.Scanner;

public class FactorialCalculation {
    public static void main(String[] args) {
        // Create a Scanner object to read input from the console.
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter a number.
        System.out.print("Enter a number: ");
        
        // Read the integer entered by the user.
        int num = scanner.nextInt();

        // Initialize a variable to store the factorial, starting with 1.
        long factorial = 1;

        // Calculate the factorial using a for loop.
        for (int i = 1; i <= num; i++) {
            factorial *= i;
        }

        // Print the result (factorial) to the console.
        System.out.println("Factorial of " + num + " is: " + factorial);
    }
}
```

Here’s a step-by-step explanation:

## Import Statement

- `import java.util.Scanner;`: This imports the `Scanner` class from the `java.util` package. The `Scanner` class is used for reading user input.

## Class Declaration

- `public class FactorialCalculation`: Declares a class named `FactorialCalculation`.

## Main Method

- `public static void main(String[] args)`: This is the main method, the entry point of the program.

## Scanner Initialization

- `Scanner scanner = new Scanner(System.in);`: Creates a `Scanner` object named `scanner` to read input from the console (`System.in`).

## User Input

- `System.out.print("Enter a number: ");`: Prints a prompt asking the user to enter a number.
- `int num = scanner.nextInt();`: Reads the integer entered by the user using the `nextInt()` method of the `Scanner` class.

## Factorial Calculation

- `long factorial = 1;`: Initializes a variable `factorial` to store the result, starting with 1.
- `for (int i = 1; i <= num; i++) { factorial *= i; }`: Uses a for loop to calculate the factorial by multiplying the current value of `factorial` by each integer from 1 to `num`.

## Print Result

- `System.out.println("Factorial of " + num + " is: " + factorial);`: Prints the result (factorial) to the console.

Wersja c#

```csharp
class Program
{
    static void Main(string[] args)
    {
        long num1 = 0;
        while (true)
        {


            // Prompt the user to enter the first number.
            Console.Write("Podaj liczbę całkowitą: ");

            // Read the first number entered by the user.
            var num1Text = Console.ReadLine();
            // int num1 = Convert.ToInt32(num1Text);
           
           if (long.TryParse(num1Text, out num1))
            {
                break;
            } else
            {
                Console.WriteLine("Bądz człowiekiem podaj liczbę całkowitą");
            }
            
        }
        // Initialize a variable to store the factorial, starting with 1.
        //Użyłem BigInteger do obsługi dużych liczb 
        
        BigInteger factorial = 1;

        // Calculate the factorial using a for loop.
        for (int i = 1; i <= num1; i++)
        {
            Console.WriteLine($"{i}*{factorial}={factorial * i}");
            factorial *= i;
        }

        // Print the result (factorial) to the console.
        Console.WriteLine("Factorial of " + num1 + " is: " + factorial);



    }
}
```









# 6. Check Palindrome

Write a Java program to check if a given string is a palindrome.

```java
import java.util.Scanner;

public class PalindromeCheck {
    public static void main(String[] args) {
        // Create a Scanner object to read input from the console.
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter a string.
        System.out.print("Enter a string: ");
        
        // Read the entire line of input entered by the user.
        String input = scanner.nextLine();

        // Create a StringBuilder object and reverse the input string.
        String reversed = new StringBuilder(input).reverse().toString();

        // Check if the reversed string is equal to the original input (ignoring case).
        if (input.equalsIgnoreCase(reversed)) {
            System.out.println(input + " is a palindrome.");
        } else {
            System.out.println(input + " is not a palindrome.");
        }
    }
}
```

Here’s a step-by-step explanation:

## Import Statement

- `import java.util.Scanner;`: This imports the `Scanner` class from the `java.util` package. The `Scanner` class is used for reading user input.

## Class Declaration

- `public class PalindromeCheck`: Declares a class named `PalindromeCheck`.

## Main Method

- `public static void main(String[] args)`: This is the main method, the entry point of the program.

## Scanner Initialization

- `Scanner scanner = new Scanner(System.in);`: Creates a `Scanner` object named `scanner` to read input from the console (`System.in`).

## User Input

- `System.out.print("Enter a string: ");`: Prints a prompt asking the user to enter a string.
- `String input = scanner.nextLine();`: Reads the entire line of input entered by the user using the `nextLine()` method of the `Scanner` class.

## String Reversal

- `String reversed = new StringBuilder(input).reverse().toString();`: Uses a `StringBuilder` to reverse the order of characters in the input string. The `reverse()` method reverses the characters, and `toString()` converts the `StringBuilder` back to a `String`.

## Palindrome Check

- `if (input.equalsIgnoreCase(reversed)) { ... }`: Checks if the original input string is equal to its reversed version,  ignoring case. If true, it means the input is a palindrome.

## Print Result

- The program then prints whether the input is a palindrome or not.

# 7. Print Multiplication Table

Write a Java program to print the multiplication table of a given number.

```java
import java.util.Scanner;

public class MultiplicationTable {
    public static void main(String[] args) {
        // Create a Scanner object to read input from the console.
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter a number.
        System.out.print("Enter a number: ");
        
        // Read the integer entered by the user.
        int num = scanner.nextInt();

        // Use a loop to generate and print the multiplication table for the entered number.
        for (int i = 1; i <= 10; i++) {
            System.out.println(num + " x " + i + " = " + (num * i));
        }
    }
}
```

Here’s a step-by-step explanation:

## Import Statement

- `import java.util.Scanner;`: This imports the `Scanner` class from the `java.util` package. The `Scanner` class is used for reading user input.

## Class Declaration

- `public class MultiplicationTable`: Declares a class named `MultiplicationTable`.

## Main Method

- `public static void main(String[] args)`: This is the main method, the entry point of the program.

## Scanner Initialization

- `Scanner scanner = new Scanner(System.in);`: Creates a `Scanner` object named `scanner` to read input from the console (`System.in`).

## User Input

- `System.out.print("Enter a number: ");`: Prints a prompt asking the user to enter a number.
- `int num = scanner.nextInt();`: Reads the integer entered by the user.

## Multiplication Table Generation

- `for (int i = 1; i <= 10; i++) { ... }`: Uses a `for` loop to iterate from 1 to 10.
- `System.out.println(num + " x " + i + " = " + (num * i));`: Prints the multiplication table entry for the current value of `i`.

## Print Result

- The program prints the multiplication table for the entered number up to 10.

# 8. Fibonacci Series

Write a Java program to generate the Fibonacci series up to a given number `n`.

```java
import java.util.Scanner;

public class FibonacciSeries {
    public static void main(String[] args) {
        // Create a Scanner object to read input from the console.
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter the value of n.
        System.out.print("Enter the value of n: ");
        
        // Read the integer entered by the user.
        int n = scanner.nextInt();

        // Initialize the first two numbers in the Fibonacci series.
        int first = 0, second = 1;

        // Print a message indicating the Fibonacci series is up to n.
        System.out.println("Fibonacci Series up to " + n + ":");

        // Use a while loop to generate and print Fibonacci numbers up to n.
        while (first <= n) {
            // Print the current Fibonacci number.
            System.out.print(first + " ");

            // Calculate the next Fibonacci number.
            int next = first + second;

            // Update first and second for the next iteration.
            first = second;
            second = next;
        }
    }
}
```

Here’s a step-by-step explanation:

## Import Statement

- `import java.util.Scanner;`: This imports the `Scanner` class from the `java.util` package. The `Scanner` class is used for reading user input.

## Class Declaration

- `public class FibonacciSeries`: Declares a class named `FibonacciSeries`.

## Main Method

- `public static void main(String[] args)`: This is the main method, the entry point of the program.

## Scanner Initialization

- `Scanner scanner = new Scanner(System.in);`: Creates a `Scanner` object named `scanner` to read input from the console (`System.in`).

## User Input

- `System.out.print("Enter the value of n: ");`: Prints a prompt asking the user to enter the value of 'n'.
- `int n = scanner.nextInt();`: Reads the integer entered by the user using the `nextInt()` method of the `Scanner` class.

## Fibonacci Series Initialization

- `int first = 0, second = 1;`: Initializes the first two numbers in the Fibonacci series.

## Print Message

- `System.out.println("Fibonacci Series up to " + n + ":");`: Prints a message indicating that the Fibonacci series is up to the specified value 'n'.

## Fibonacci Series Generation

- `while (first <= n) { ... }`: Uses a while loop to generate and print Fibonacci numbers until the current Fibonacci number exceeds 'n'.
- `System.out.print(first + " ");`: Prints the current Fibonacci number.
- `int next = first + second;`: Calculates the next Fibonacci number.
- `first = second; second = next;`: Updates the values of 'first' and 'second' for the next iteration.

# 9. Prime Number Check

Write a Java program to check if a given number is prime.

```java
import java.util.Scanner;

public class PrimeNumberCheck {
    public static void main(String[] args) {
        // Create a Scanner object to read input from the console.
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter a number.
        System.out.print("Enter a number: ");
        
        // Read the integer entered by the user.
        int num = scanner.nextInt();

        // Assume the number is prime initially.
        boolean isPrime = true;

        // Check if the number is less than or equal to 1.
        if (num <= 1) {
            isPrime = false;
        } else {
            // Use a for loop to check for factors up to the square root of the number.
            for (int i = 2; i <= Math.sqrt(num); i++) {
                if (num % i == 0) {
                    // If the number is divisible by i, it's not prime.
                    isPrime = false;
                    break;
                }
            }
        }
        
        // Print whether the number is prime or not.
        if (isPrime) {
            System.out.println(num + " is a prime number.");
        } else {
            System.out.println(num + " is not a prime number.");
        }
    }
}
```

Here’s a step-by-step explanation:

## Import Statement

- `import java.util.Scanner;`: This imports the `Scanner` class from the `java.util` package. The `Scanner` class is used for reading user input.

## Class Declaration

- `public class PrimeNumberCheck`: Declares a class named `PrimeNumberCheck`.

## Main Method

- `public static void main(String[] args)`: This is the main method, the entry point of the program.

## Scanner Initialization

- `Scanner scanner = new Scanner(System.in);`: Creates a `Scanner` object named `scanner` to read input from the console (`System.in`).

## User Input

- `System.out.print("Enter a number: ");`: Prints a prompt asking the user to enter a number.
- `int num = scanner.nextInt();`: Reads the integer entered by the user using the `nextInt()` method of the `Scanner` class.

## Prime Number Check

- `boolean isPrime = true;`: Assumes the number is prime initially.
- `if (num <= 1) { isPrime = false; }`: Checks if the number is less than or equal to 1; in such cases, it's not considered prime.
- `else { ... }`: If the number is greater than 1, a for loop is used to check for factors up to the square root of the number.
- `if (num % i == 0) { isPrime = false; break; }`: If the number is divisible by any value of 'i', it's not prime, and the loop breaks.

## Print Result

- `if (isPrime) { System.out.println(num + " is a prime number."); }`: Prints whether the number is prime or not.

# 10. Find Maximum in Array

Write a Java program to find the maximum element in an array.

```java
import java.util.Scanner;

public class FindMaxInArray {
    public static void main(String[] args) {
        // Create a Scanner object to read input from the console.
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter the size of the array.
        System.out.print("Enter the size of the array: ");
        
        // Read the size entered by the user.
        int size = scanner.nextInt();

        // Create an array with the specified size.
        int[] array = new int[size];

        // Prompt the user to enter elements of the array.
        System.out.print("Enter elements of the array: ");

        // Use a for loop to read elements into the array.
        for (int i = 0; i < size; i++) {
            array[i] = scanner.nextInt();
        }

        // Initialize the maximum element with the first element of the array.
        int max = array[0];

        // Use an enhanced for loop to find the maximum element in the array.
        for (int num : array) {
            if (num > max) {
                max = num;
            }
        }

        // Print the maximum element in the array.
        System.out.println("Maximum element in the array: " + max);
    }
}
```

Here’s a step-by-step explanation:

## Import Statement

- `import java.util.Scanner;`: This imports the `Scanner` class from the `java.util` package. The `Scanner` class is used for reading user input.

## Class Declaration

- `public class FindMaxInArray`: Declares a class named `FindMaxInArray`.

## Main Method

- `public static void main(String[] args)`: This is the main method, the entry point of the program.

## Scanner Initialization

- `Scanner scanner = new Scanner(System.in);`: Creates a `Scanner` object named `scanner` to read input from the console (`System.in`).

## User Input — Array Size

- `System.out.print("Enter the size of the array: ");`: Prints a prompt asking the user to enter the size of the array.
- `int size = scanner.nextInt();`: Reads the size entered by the user using the `nextInt()` method of the `Scanner` class.

## Array Initialization

- `int[] array = new int[size];`: Creates an array with the specified size.

## User Input — Array Elements

- `System.out.print("Enter elements of the array: ");`: Prints a prompt asking the user to enter the elements of the array.
- `for (int i = 0; i < size; i++) { array[i] = scanner.nextInt(); }`: Uses a for loop to read elements into the array.

## Find Maximum Element

- `int max = array[0];`: Initializes the maximum element with the first element of the array.
- `for (int num : array) { if (num > max) { max = num; } }`: Uses an enhanced for loop to find the maximum element in the array.

## Print Result

- `System.out.println("Maximum element in the array: " + max);`: Prints the maximum element in the array.

# 11. Check Leap Year

Write a Java program to check if a given year is a leap year.

```java
import java.util.Scanner;

public class LeapYearCheck {
    public static void main(String[] args) {
        // Create a Scanner object to read input from the console.
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter a year.
        System.out.print("Enter a year: ");
        
        // Read the integer entered by the user.
        int year = scanner.nextInt();

        // Assume the year is not a leap year initially.
        boolean isLeapYear = false;

        // Check if the year is a leap year based on the leap year rules.
        if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {
            isLeapYear = true;
        }
        
        // Print whether the year is a leap year or not.
        if (isLeapYear) {
            System.out.println(year + " is a leap year.");
        } else {
            System.out.println(year + " is not a leap year.");
        }
    }
}
```

Here’s a step-by-step explanation:

## Import Statement

- `import java.util.Scanner;`: This imports the `Scanner` class from the `java.util` package. The `Scanner` class is used for reading user input.

## Class Declaration

- `public class LeapYearCheck`: Declares a class named `LeapYearCheck`.

## Main Method

- `public static void main(String[] args)`: This is the main method, the entry point of the program.

## Scanner Initialization

- `Scanner scanner = new Scanner(System.in);`: Creates a `Scanner` object named `scanner` to read input from the console (`System.in`).

## User Input

- `System.out.print("Enter a year: ");`: Prints a prompt asking the user to enter a year.
- `int year = scanner.nextInt();`: Reads the integer entered by the user using the `nextInt()` method of the `Scanner` class.

## Leap Year Check

- `boolean isLeapYear = false;`: Assumes the year is not a leap year initially.
- `if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) { isLeapYear = true; }`: Checks if the year is a leap year based on the leap year rules.

## Print Result

- `if (isLeapYear) { System.out.println(year + " is a leap year."); }`: Prints whether the year is a leap year or not.

# 12. Calculate Average

Write a Java program to calculate the average of elements in an array.

```java
import java.util.Scanner;

public class CalculateAverage {
    public static void main(String[] args) {
        // Create a Scanner object to read input from the console.
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter the size of the array.
        System.out.print("Enter the size of the array: ");
        
        // Read the size entered by the user.
        int size = scanner.nextInt();

        // Create an array with the specified size.
        int[] array = new int[size];

        // Prompt the user to enter elements of the array.
        System.out.print("Enter elements of the array: ");

        // Use a for loop to read elements into the array.
        for (int i = 0; i < size; i++) {
            array[i] = scanner.nextInt();
        }

        // Calculate the sum of elements in the array.
        int sum = 0;
        for (int num : array) {
            sum += num;
        }

        // Calculate the average (casting sum to double for accurate division).
        double average = (double) sum / size;

        // Print the average of elements in the array.
        System.out.println("Average of elements in the array: " + average);
    }
}
```

Here’s a step-by-step explanation:

## Import Statement

- `import java.util.Scanner;`: This imports the `Scanner` class from the `java.util` package. The `Scanner` class is used for reading user input.

## Class Declaration

- `public class CalculateAverage`: Declares a class named `CalculateAverage.`

## Main Method

- `public static void main(String[] args)`: This is the main method, the entry point of the program.

## Scanner Initialization

- `Scanner scanner = new Scanner(System.in);`: Creates a `Scanner` object named `scanner` to read input from the console (`System.in`).

## User Input — Array Size

- `System.out.print("Enter the size of the array: ");`: Prints a prompt asking the user to enter the size of the array.
- `int size = scanner.nextInt();`: Reads the size entered by the user using the `nextInt()` method of the `Scanner` class.

## Array Initialization

- `int[] array = new int[size];`: Creates an array with the specified size.

## User Input — Array Elements

- `System.out.print("Enter elements of the array: ");`: Prints a prompt asking the user to enter the elements of the array.
- `for (int i = 0; i < size; i++) { array[i] = scanner.nextInt(); }`: Uses a for loop to read elements into the array.

## Calculate Sum

- `int sum = 0;`: Initializes the sum of elements to zero.
- `for (int num : array) { sum += num; }`: Uses an enhanced for loop to calculate the sum of elements in the array.

## Calculate Average

- `double average = (double) sum / size;`: Calculates the average (casting `sum` to `double` for accurate division).

## Print Result

- `System.out.println("Average of elements in the array: " + average);`: Prints the average of elements in the array.

# 13. Count Vowels in a String

Write a Java program to count the number of vowels in a given string.

```java
import java.util.Scanner;

public class CountVowels {
    public static void main(String[] args) {
        // Create a Scanner object to read input from the console.
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter a string.
        System.out.print("Enter a string: ");
        
        // Read the entire line of input entered by the user.
        String input = scanner.nextLine();

        // Initialize the count of vowels to zero.
        int vowelCount = 0;

        // Use an enhanced for loop to iterate over each character in the string.
        for (char ch : input.toLowerCase().toCharArray()) {
            // Check if the character is a vowel (case-insensitive).
            if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') {
                vowelCount++;
            }
        }

        // Print the number of vowels in the string.
        System.out.println("Number of vowels in the string: " + vowelCount);
    }
}
```

Here’s a step-by-step explanation:

## Import Statement

- `import java.util.Scanner;`: This imports the `Scanner` class from the `java.util` package. The `Scanner` class is used for reading user input.

## Class Declaration

- `public class CountVowels`: Declares a class named `CountVowels`.

## Main Method

- `public static void main(String[] args)`: This is the main method, the entry point of the program.

## Scanner Initialization

- `Scanner scanner = new Scanner(System.in);`: Creates a `Scanner` object named `scanner` to read input from the console (`System.in`).

## User Input

- `System.out.print("Enter a string: ");`: Prints a prompt asking the user to enter a string.
- `String input = scanner.nextLine();`: Reads the entire line of input entered by the user using the `nextLine()` method of the `Scanner` class.

## Vowel Counting

- `int vowelCount = 0;`: Initializes the count of vowels to zero.
- `for (char ch : input.toLowerCase().toCharArray()) { ... }`: Uses an enhanced for loop to iterate over each character in the string, converting the string to lowercase to make the comparison  case-insensitive.
- `if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') { vowelCount++; }`: Checks if the character is a vowel (case-insensitive) and increments the vowel count if true.

## Print Result

- `System.out.println("Number of vowels in the string: " + vowelCount);`: Prints the number of vowels in the string.

# 14. Calculate Power

Write a Java program to calculate the power of a number.

```java
import java.util.Scanner;

public class CalculatePower {
    public static void main(String[] args) {
        // Create a Scanner object to read input from the console.
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter the base.
        System.out.print("Enter the base: ");
        
        // Read the integer entered by the user as the base.
        int base = scanner.nextInt();

        // Prompt the user to enter the exponent.
        System.out.print("Enter the exponent: ");
        
        // Read the integer entered by the user as the exponent.
        int exponent = scanner.nextInt();

        // Initialize the result to 1.
        long result = 1;

        // Use a for loop to calculate the power.
        for (int i = 0; i < exponent; i++) {
            result *= base;
        }

        // Print the result of the power calculation.
        System.out.println(base + " ^ " + exponent + " = " + result);
    }
}
```

Here’s a step-by-step explanation:

## Import Statement

- `import java.util.Scanner;`: This imports the `Scanner` class from the `java.util` package. The `Scanner` class is used for reading user input.

## Class Declaration

- `public class CalculatePower`: Declares a class named `CalculatePower`.

## Main Method

- `public static void main(String[] args)`: This is the main method, the entry point of the program.

## Scanner Initialization

- `Scanner scanner = new Scanner(System.in);`: Creates a `Scanner` object named `scanner` to read input from the console (`System.in`).

## User Input — Base

- `System.out.print("Enter the base: ");`: Prints a prompt asking the user to enter the base.
- `int base = scanner.nextInt();`: Reads the integer entered by the user using the `nextInt()` method of the `Scanner` class.

## User Input — Exponent

- `System.out.print("Enter the exponent: ");`: Prints a prompt asking the user to enter the exponent.
- `int exponent = scanner.nextInt();`: Reads the integer entered by the user as the exponent.

## Power Calculation

- `long result = 1;`: Initializes the result to 1.
- `for (int i = 0; i < exponent; i++) { result *= base; }`: Uses a for loop to perform the power calculation by multiplying the base 'exponent' times.

## Print Result

- `System.out.println(base + " ^ " + exponent + " = " + result);`: Prints the result of the power calculation.

# 15. Binary to Decimal

Write a Java program to convert a binary number to decimal.

```java
import java.util.Scanner;

public class BinaryToDecimal {
    public static void main(String[] args) {
        // Create a Scanner object to read input from the console.
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter a binary number.
        System.out.print("Enter a binary number: ");
        
        // Read the binary number entered by the user as a string.
        String binaryStr = scanner.next();

        // Use Integer.parseInt to convert the binary string to decimal.
        int decimal = Integer.parseInt(binaryStr, 2);

        // Print the decimal equivalent.
        System.out.println("Decimal equivalent: " + decimal);
    }
}
```

Here’s a step-by-step explanation:

## Import Statement

- `import java.util.Scanner;`: This imports the `Scanner` class from the `java.util` package. The `Scanner` class is used for reading user input.

## Class Declaration

- `public class BinaryToDecimal`: Declares a class named `BinaryToDecimal`.

## Main Method

- `public static void main(String[] args)`: This is the main method, the entry point of the program.

## Scanner Initialization

- `Scanner scanner = new Scanner(System.in);`: Creates a `Scanner` object named `scanner` to read input from the console (`System.in`).

## User Input — Binary Number

- `System.out.print("Enter a binary number: ");`: Prints a prompt asking the user to enter a binary number.
- `String binaryStr = scanner.next();`: Reads the binary number entered by the user as a string using the `next()` method of the `Scanner` class.

## Binary to Decimal Conversion

- `int decimal = Integer.parseInt(binaryStr, 2);`: Uses `Integer.parseInt` to convert the binary string to decimal. The second argument '2' specifies that the input is in base-2 (binary).

## Print Result

- `System.out.println("Decimal equivalent: " + decimal);`: Prints the decimal equivalent of the entered binary number.

# 16. Check Armstrong Number

Write a Java program to check if a given number is an Armstrong number.

```java
import java.util.Scanner;

public class ArmstrongNumberCheck {
    public static void main(String[] args) {
        // Create a Scanner object to read input from the console.
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter a number.
        System.out.print("Enter a number: ");
        
        // Read the integer entered by the user.
        int num = scanner.nextInt();

        // Store the original number for comparison later.
        int originalNum = num;

        // Initialize the sum of powered digits to 0.
        int sum = 0;

        // Count the number of digits in the input number.
        int digitCount = String.valueOf(num).length();

        // Use a while loop to calculate the sum of powered digits.
        while (num > 0) {
            int digit = num % 10;
            sum += Math.pow(digit, digitCount);
            num /= 10;
        }

        // Check if the sum is equal to the original number.
        if (sum == originalNum) {
            System.out.println(originalNum + " is an Armstrong number.");
        } else {
            System.out.println(originalNum + " is not an Armstrong number.");
        }
    }
}
```

Here’s a step-by-step explanation:

## Import Statement

- `import java.util.Scanner;`: This imports the `Scanner` class from the `java.util` package. The `Scanner` class is used for reading user input.

## Class Declaration

- `public class ArmstrongNumberCheck`: Declares a class named `ArmstrongNumberCheck`.

## Main Method

- `public static void main(String[] args)`: This is the main method, the entry point of the program.

## Scanner Initialization

- `Scanner scanner = new Scanner(System.in);`: Creates a `Scanner` object named `scanner` to read input from the console (`System.in`).

## User Input

- `System.out.print("Enter a number: ");`: Prints a prompt asking the user to enter a number.
- `int num = scanner.nextInt();`: Reads the integer entered by the user using the `nextInt()` method of the `Scanner` class.

## Store Original Number

- `int originalNum = num;`: Stores the original number for later comparison.

## Initialization

- `int sum = 0;`: Initializes the sum of powered digits to 0.
- `int digitCount = String.valueOf(num).length();`: Counts the number of digits in the input number.

## Calculate Sum of Powered Digits

- `while (num > 0) { int digit = num % 10; sum += Math.pow(digit, digitCount); num /= 10; }`: Uses a while loop to calculate the sum of powered digits by iterating over each digit of the number.

## Check if Armstrong Number

- `if (sum == originalNum) { System.out.println(originalNum + " is an Armstrong number."); }`: Checks if the sum of powered digits is equal to the original number and prints the result.

## Print Result

- `else { System.out.println(originalNum + " is not an Armstrong number."); }`: Prints the result if the number is not an Armstrong number.

# 17. Print Pattern

Write a Java program to print the following pattern:

```java
public class PrintPattern {
    public static void main(String[] args) {
        // Define the number of rows in the triangle
        int rows = 5;

        // Outer loop for the number of rows
        for (int i = 1; i <= rows; i++) {
            // Inner loop to print asterisks in each row
            for (int j = 1; j <= i; j++) {
                System.out.print("*");
            }
            // Move to the next line after each row
            System.out.println();
        }
    }
}
```

Here’s a step-by-step explanation:

## Class Declaration

- `public class PrintPattern`: Declares a class named `PrintPattern`.

## Main Method

- `public static void main(String[] args)`: This is the main method, the entry point of the program.

## Define Rows

- `int rows = 5;`: Sets the variable `rows` to 5, determining the number of rows in the triangle.

## Outer Loop — Rows

- `for (int i = 1; i <= rows; i++) { ... }`: The outer loop controls the number of rows in the triangle. It iterates from 1 to the specified number of rows (`rows`).

## Inner Loop — Asterisks

- `for (int j = 1; j <= i; j++) { System.out.print("*"); }`: The inner loop prints asterisks in each row. It iterates from 1 to the current value of `i`, printing an asterisk in each iteration.

## New Line

- `System.out.println();`: This statement moves to the next line after each row of asterisks is printed.

When you run this program, it will output the right-angled triangle pattern you provided:

```
*
**
***
****
*****
```

# 18. Bubble Sort

Write a Java program to implement the Bubble Sort algorithm.

```java
import java.util.Arrays;

public class BubbleSort {
    public static void main(String[] args) {
        // Define an array of integers
        int[] array = {5, 2, 8, 9, 1};
        
        // Print the original array
        System.out.println("Original Array: " + Arrays.toString(array));
        
        // Outer loop for the number of passes
        for (int i = 0; i < array.length - 1; i++) {
            // Inner loop for comparing and swapping elements
            for (int j = 0; j < array.length - i - 1; j++) {
                // Compare adjacent elements and swap if they are in the wrong order
                if (array[j] > array[j + 1]) {
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
        
        // Print the sorted array
        System.out.println("Sorted Array: " + Arrays.toString(array));
    }
}
```

Here’s a step-by-step explanation:

## Import Statement

- `import java.util.Arrays;`: This imports the `Arrays` class from the `java.util` package. The `Arrays.toString()` method is used to print the array in a readable format.

## Class Declaration

- `public class BubbleSort`: Declares a class named `BubbleSort`.

## Main Method

- `public static void main(String[] args)`: This is the main method, the entry point of the program.

## Array Initialization

- `int[] array = {5, 2, 8, 9, 1};`: Initializes an array of integers with the given values.

## Print Original Array

- `System.out.println("Original Array: " + Arrays.toString(array));`: Prints the original array before sorting.

## Bubble Sort Implementation

- The outer loop (`for (int i = 0; i < array.length - 1; i++)`) represents the number of passes, where each pass compares and potentially swaps adjacent elements.
- The inner loop (`for (int j = 0; j < array.length - i - 1; j++)`) iterates over the unsorted part of the array.
- If an element is greater than its adjacent element, they are swapped to bring the larger element towards the end of the array.

## Print Sorted Array

- `System.out.println("Sorted Array: " + Arrays.toString(array));`: Prints the sorted array after completing the Bubble Sort.

When you run this program, it will output the original array and the sorted  array using the Bubble Sort algorithm. The sorted array will be in  ascending order

```
Original Array: [5, 2, 8, 9, 1]
Sorted Array: [1, 2, 5, 8, 9]
```

# 19. Find Duplicate Elements

Write a Java program to find and print duplicate elements in an array.

```v
import java.util.HashSet;

public class FindDuplicates {
    public static void main(String[] args) {
        // Define the array with some elements (including duplicates)
        int[] array = {3, 5, 7, 2, 5, 8, 7, 4};

        // Create a HashSet to store unique elements
        HashSet<Integer> uniqueSet = new HashSet<>();

        // Create a HashSet to store duplicate elements
        HashSet<Integer> duplicateSet = new HashSet<>();

        // Iterate through the array
        for (int num : array) {
            // Attempt to add the current element to the uniqueSet
            if (!uniqueSet.add(num)) {
                // If add returns false, the element is already in the set (duplicate)
                duplicateSet.add(num);
            }
        }

        // Print the duplicate elements
        System.out.println("Duplicate elements: " + duplicateSet);
    }
}
```

Here’s a step-by-step explanation:

## Import Statement

- `import java.util.HashSet;`: This imports the `HashSet` class from the `java.util` package. The `HashSet` is used to store unique elements.

## Class Declaration

- `public class FindDuplicates`: Declares a class named `FindDuplicates`.

## Main Method

- `public static void main(String[] args)`: This is the main method, the entry point of the program.

## Array Initialization

- `int[] array = {3, 5, 7, 2, 5, 8, 7, 4};`: Initializes an array with some elements, including duplicates.

## HashSet Initialization

- `HashSet<Integer> uniqueSet = new HashSet<>();`: Creates a `HashSet` named `uniqueSet` to store unique elements.
- `HashSet<Integer> duplicateSet = new HashSet<>();`: Creates a `HashSet` named `duplicateSet` to store duplicate elements.

## Check for Duplicates

- `for (int num : array) { ... }`: Iterates through each element in the array.
- `if (!uniqueSet.add(num)) { duplicateSet.add(num); }`: Attempts to add the current element to the `uniqueSet`. If the `add` method returns `false`, it means the element is already in the set, so it is added to the `duplicateSet`.

## Print Result

- `System.out.println("Duplicate elements: " + duplicateSet);`: Prints the set of duplicate elements.

# 20. String Concatenation

Write a Java program to concatenate two strings.

```java
import java.util.Scanner;

public class StringConcatenation {
    public static void main(String[] args) {
        // Create a Scanner object to read input from the console.
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter the first string.
        System.out.print("Enter the first string: ");
        
        // Read the entire line of input entered by the user as the first string.
        String str1 = scanner.nextLine();

        // Prompt the user to enter the second string.
        System.out.print("Enter the second string: ");
        
        // Read the entire line of input entered by the user as the second string.
        String str2 = scanner.nextLine();

        // Concatenate the two strings with a space in between.
        String result = str1 + " " + str2;

        // Print the concatenated string.
        System.out.println("Concatenated string: " + result);
    }
}
```

Here’s a step-by-step explanation:

## Import Statement

- `import java.util.Scanner;`: This imports the `Scanner` class from the `java.util` package. The `Scanner` class is used for reading user input.

## Class Declaration

- `public class StringConcatenation`: Declares a class named `StringConcatenation`.

## Main Method

- `public static void main(String[] args)`: This is the main method, the entry point of the program.

## Scanner Initialization

- `Scanner scanner = new Scanner(System.in);`: Creates a `Scanner` object named `scanner` to read input from the console (`System.in`).

## User Input — First String

- `System.out.print("Enter the first string: ");`: Prints a prompt asking the user to enter the first string.
- `String str1 = scanner.nextLine();`: Reads the entire line of input entered by the user using the `nextLine()` method of the `Scanner` class.

## User Input — Second String

- `System.out.print("Enter the second string: ");`: Prints a prompt asking the user to enter the second string.
- `String str2 = scanner.nextLine();`: Reads the entire line of input entered by the user as the second string.

## String Concatenation

- `String result = str1 + " " + str2;`: Concatenates the two strings with a space in between.

## Print Result

- `System.out.println("Concatenated string: " + result);`: Prints the concatenated string.

# 21. Sum of Natural Numbers

Write a Java program to calculate the sum of the first `n` natural numbers.

```java
import java.util.Scanner;

public class SumOfNaturalNumbers {
    public static void main(String[] args) {
        // Create a Scanner object to read input from the console.
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter a positive integer (n).
        System.out.print("Enter a positive integer (n): ");
        
        // Read the positive integer entered by the user.
        int n = scanner.nextInt();

        // Calculate the sum of the first 'n' natural numbers using the formula.
        int sum = (n * (n + 1)) / 2;

        // Print the result.
        System.out.println("Sum of the first " + n + " natural numbers: " + sum);
    }
}
```

Here’s a step-by-step explanation:

## Import Statement

- `import java.util.Scanner;`: This imports the `Scanner` class from the `java.util` package. The `Scanner` class is used for reading user input.

## Class Declaration

- `public class SumOfNaturalNumbers`: Declares a class named `SumOfNaturalNumbers`.

## Main Method

- `public static void main(String[] args)`: This is the main method, the entry point of the program.

## Scanner Initialization

- `Scanner scanner = new Scanner(System.in);`: Creates a `Scanner` object named `scanner` to read input from the console (`System.in`).

## User Input — Positive Integer (n)

- `System.out.print("Enter a positive integer (n): ");`: Prints a prompt asking the user to enter a positive integer.
- `int n = scanner.nextInt();`: Reads the positive integer entered by the user using the `nextInt()` method of the `Scanner` class.

## Sum Calculation

- `int sum = (n * (n + 1)) / 2;`: Calculates the sum of the first 'n' natural numbers using the formula `(n * (n + 1)) / 2.`

## Print Result

- `System.out.println("Sum of the first " + n + " natural numbers: " + sum);`: Prints the calculated sum.

# 22. Remove Spaces from String

Write a Java program to remove spaces from a given string.

```java
import java.util.Scanner;

public class RemoveSpaces {
    public static void main(String[] args) {
        // Create a Scanner object to read input from the console.
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter a string.
        System.out.print("Enter a string: ");
        
        // Read the entire line of input entered by the user.
        String input = scanner.nextLine();

        // Use the replaceAll method to remove spaces (whitespace characters).
        String stringWithoutSpaces = input.replaceAll("\\s", "");

        // Print the result.
        System.out.println("String without spaces: " + stringWithoutSpaces);
    }
}
```

Here’s a step-by-step explanation:

## Import Statement

- `import java.util.Scanner;`: This imports the `Scanner` class from the `java.util` package. The `Scanner` class is used for reading user input.

## Class Declaration

- `public class RemoveSpaces`: Declares a class named `RemoveSpaces`.

## Main Method

- `public static void main(String[] args)`: This is the main method, the entry point of the program.

## Scanner Initialization

- `Scanner scanner = new Scanner(System.in);`: Creates a `Scanner` object named `scanner` to read input from the console (`System.in`).

## User Input — String

- `System.out.print("Enter a string: ");`: Prints a prompt asking the user to enter a string.
- `String input = scanner.nextLine();`: Reads the entire line of input entered by the user using the `nextLine()` method of the `Scanner` class.

## Remove Spaces

- `String stringWithoutSpaces = input.replaceAll("\\s", "");`: Uses the `replaceAll` method to replace all occurrences of whitespace characters (denoted by the regular expression `\\s`) with an empty string.

## Print Result

- `System.out.println("String without spaces: " + stringWithoutSpaces);`: Prints the resulting string without spaces.

# 23. Check Anagram

Write a Java program to check if two strings are anagrams.

```java
import java.util.Arrays;
import java.util.Scanner;

public class AnagramCheck {
    public static void main(String[] args) {
        // Create a Scanner object to read input from the console.
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter the first string.
        System.out.print("Enter the first string: ");
        
        // Read the entire line of input entered by the user as the first string.
        String str1 = scanner.nextLine();

        // Prompt the user to enter the second string.
        System.out.print("Enter the second string: ");
        
        // Read the entire line of input entered by the user as the second string.
        String str2 = scanner.nextLine();

        // Convert the strings to character arrays.
        char[] charArray1 = str1.toCharArray();
        char[] charArray2 = str2.toCharArray();

        // Sort the character arrays.
        Arrays.sort(charArray1);
        Arrays.sort(charArray2);

        // Check if the sorted arrays are equal (anagrams).
        boolean areAnagrams = Arrays.equals(charArray1, charArray2);

        // Print the result.
        if (areAnagrams) {
            System.out.println("The strings are anagrams.");
        } else {
            System.out.println("The strings are not anagrams.");
        }
    }
}
```

Here’s a step-by-step explanation:

## Import Statements

- `import java.util.Arrays;`: This imports the `Arrays` class from the `java.util` package. The `Arrays` class provides utility methods for manipulating arrays.

## Class Declaration

- `public class AnagramCheck`: Declares a class named `AnagramCheck`.

## Main Method

- `public static void main(String[] args)`: This is the main method, the entry point of the program.

## Scanner Initialization

- `Scanner scanner = new Scanner(System.in);`: Creates a `Scanner` object named `scanner` to read input from the console (`System.in`).

## User Input — First String

- `System.out.print("Enter the first string: ");`: Prints a prompt asking the user to enter the first string.
- `String str1 = scanner.nextLine();`: Reads the entire line of input entered by the user as the first string.

## User Input — Second String

- `System.out.print("Enter the second string: ");`: Prints a prompt asking the user to enter the second string.
- `String str2 = scanner.nextLine();`: Reads the entire line of input entered by the user as the second string.

## Convert Strings to Character Arrays

- `char[] charArray1 = str1.toCharArray();`: Converts the first string to a character array.
- `char[] charArray2 = str2.toCharArray();`: Converts the second string to a character array.

## Sort Character Arrays

- `Arrays.sort(charArray1);`: Sorts the character array for the first string.
- `Arrays.sort(charArray2);`: Sorts the character array for the second string.

## Check for Anagrams

- `boolean areAnagrams = Arrays.equals(charArray1, charArray2);`: Checks if the sorted character arrays are equal, indicating that the strings are anagrams.

## Print Result

- `if (areAnagrams) { System.out.println("The strings are anagrams."); }`: Prints a message if the strings are anagrams.
- `else { System.out.println("The strings are not anagrams."); }`: Prints a message if the strings are not anagrams.

# 24. Swap Two Numbers

Write a Java program to swap the values of two variables.

```java
import java.util.Scanner;

public class SwapNumbers {
    public static void main(String[] args) {
        // Create a Scanner object to read input from the console.
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter the first number.
        System.out.print("Enter the first number: ");
        
        // Read the first number entered by the user.
        int num1 = scanner.nextInt();

        // Prompt the user to enter the second number.
        System.out.print("Enter the second number: ");
        
        // Read the second number entered by the user.
        int num2 = scanner.nextInt();

        // Print the numbers before swapping.
        System.out.println("Before swapping: num1 = " + num1 + ", num2 = " + num2);

        // Swap the values of num1 and num2 using a temporary variable.
        int temp = num1;
        num1 = num2;
        num2 = temp;

        // Print the numbers after swapping.
        System.out.println("After swapping: num1 = " + num1 + ", num2 = " + num2);
    }
}
```

Here’s a step-by-step explanation:

## Import Statement

- `import java.util.Scanner;`: This imports the `Scanner` class from the `java.util` package. The `Scanner` class is used for reading user input.

## Class Declaration

- `public class SwapNumbers`: Declares a class named `SwapNumbers`.

## Main Method

- `public static void main(String[] args)`: This is the main method, the entry point of the program.

## Scanner Initialization

- `Scanner scanner = new Scanner(System.in);`: Creates a `Scanner` object named `scanner` to read input from the console (`System.in`).

## User Input — First Number

- `System.out.print("Enter the first number: ");`: Prints a prompt asking the user to enter the first number.
- `int num1 = scanner.nextInt();`: Reads the first number entered by the user using the `nextInt()` method of the `Scanner` class.

## User Input — Second Number

- `System.out.print("Enter the second number: ");`: Prints a prompt asking the user to enter the second number.
- `int num2 = scanner.nextInt();`: Reads the second number entered by the user using the `nextInt()` method of the `Scanner` class.

## Print Numbers Before Swapping

- `System.out.println("Before swapping: num1 = " + num1 + ", num2 = " + num2);`: Prints the values of `num1` and `num2` before the swapping process.

## Swap Numbers Using a Temporary Variable

- `int temp = num1; num1 = num2; num2 = temp;`: Swaps the values of `num1` and `num2` using a temporary variable.

## Print Numbers After Swapping

- `System.out.println("After swapping: num1 = " + num1 + ", num2 = " + num2);`: Prints the values of `num1` and `num2` after the swapping process.

# 25. Armstrong Numbers in a Range

Napisz program Java, aby znaleźć i wydrukować numery Armstronga w danym zakresie.

Liczby Armstronga, znane również jako liczby narcystyczne, to specjalne liczby całkowite, które spełniają określone kryterium. Sprawdźmy je:

Liczba Armstronga to taka, w której suma cyfr, każda podniesiona do potęgi liczby cyfr w danej liczbie, równa się oryginalnej liczbie.
Oto liczby Armstronga w zakresie od 1 do 5000:
1, 2, 3, 4, 5, 6, 7, 8, 9
153, 370, 371, 407
1634
8208
9474

Na przykład, weźmy 371:
(3^3 + 7^3 + 1^3 = 371)



```java
import java.util.Scanner;

public class ArmstrongNumbersInRange {
    public static void main(String[] args) {
        // Create a Scanner object to read input from the console.
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter the starting range.
        System.out.print("Enter the starting range: ");

        // Read the starting range entered by the user.
        int startRange = scanner.nextInt();

        // Prompt the user to enter the ending range.
        System.out.print("Enter the ending range: ");

        // Read the ending range entered by the user.
        int endRange = scanner.nextInt();

        // Print the header for the Armstrong numbers in the specified range.
        System.out.println("Armstrong numbers in the range " + startRange + " to " + endRange + ":");

        // Iterate through the numbers in the specified range.
        for (int num = startRange; num <= endRange; num++) {
            int originalNum = num;
            int sum = 0;
            int digitCount = String.valueOf(num).length();
            int tempNum = num;  // Store the original value of num

            // Use a while loop to calculate the sum of powered digits.
            while (tempNum > 0) {
                int digit = tempNum % 10;
                sum += Math.pow(digit, digitCount);
                tempNum /= 10;
            }

            // Check if the sum is equal to the original number (Armstrong number).
            if (sum == originalNum) {
                System.out.print(originalNum + " ");
            }
        }

        // Close the scanner to prevent resource leaks.
        scanner.close();
    }
}
```

Here’s a step-by-step explanation:

## Import Statement

- `import java.util.Scanner;`: This imports the `Scanner` class from the `java.util` package. The `Scanner` class is used for reading user input.

## Class Declaration

- `public class ArmstrongNumbersInRange`: Declares a class named `ArmstrongNumbersInRange`.

## Main Method

- `public static void main(String[] args)`: This is the main method, the entry point of the program.

## Scanner Initialization

- `Scanner scanner = new Scanner(System.in);`: Creates a `Scanner` object named `scanner` to read input from the console (`System.in`).

## User Input — Starting Range

- `System.out.print("Enter the starting range: ");`: Prints a prompt asking the user to enter the starting range.
- `int startRange = scanner.nextInt();`: Reads the starting range entered by the user using the `nextInt()` method of the `Scanner` class.

## User Input — Ending Range

- `System.out.print("Enter the ending range: ");`: Prints a prompt asking the user to enter the ending range.
- `int endRange = scanner.nextInt();`: Reads the ending range entered by the user using the `nextInt()` method of the `Scanner` class.

## Print Header

- `System.out.println("Armstrong numbers in the range " + startRange + " to " + endRange + ":");`: Prints the header for the Armstrong numbers in the specified range.

## Iterate Through Range

- `for (int num = startRange; num <= endRange; num++) { ... }`: Uses a for loop to iterate through the numbers in the specified range.

## Calculate Sum of Powered Digits

- `while (num > 0) { int digit = num % 10; sum += Math.pow(digit, digitCount); num /= 10; }`: Uses a while loop to calculate the sum of powered digits by iterating over each digit of the number.

## Check for Armstrong Number

- `if (sum == originalNum) { System.out.print(originalNum + " "); }`: Checks if the sum is equal to the original number. If true, it prints the number as an Armstrong number.

# Conclusion

These 25 Java coding exercises provide a well-rounded set of challenges for  learners at different stages of their programming journey. By working  through these exercises, students can build a strong foundation in Java  programming, gaining confidence in applying essential concepts and  problem-solving skills. These exercises serve as an excellent resource  for practice, helping learners reinforce their understanding and develop the coding skills necessary for real-world applications.





# Algorytmy są zajebiste



Będę szczery, rozpoczęcie nauki o strukturach danych i algorytmach było oszałamiająco trudne.

Jednak im bardziej wytrwałem, tym bardziej odkrywałem pewne algorytmy, które mogłem określić jedynie jako 'piękne'.

Oto 5 z tych algorytmów.

# 1. Euclid’s Algorithm

## Podejście Amatorskie

Próbując obliczyć największy wspólny dzielnik dwóch liczb całkowitych, amator podjąłbym następujące kroki.

```
def find_gcd(x, y):
    gcd = 1
    
    min_num = min(x, y)
    
    for i in range(1, min_num + 1):
        if x % i == 0 and y % i == 0:
            gcd = i
    
    return gcd
```

Powyższa funkcja iteruje przez wszystkie liczby od 1 do mniejszej z dwóch podanych liczb całkowitych.

Dla każdej liczby i sprawdza, czy obie podane liczby całkowite są podzielne przez i. W takim przypadku ta liczba jest zwracana w rezultacie.

## Zajebisty Algorytm

Nadchodzi Algorytm Euklidesa.

Algorytm ten jest skuteczną metodą obliczania największego wspólnego dzielnika (GCD) dwóch liczb całkowitych.

Algorytm opiera się na zasadzie, że GCD dwóch liczb również dzieli ich różnicę.

Oto jak to wygląda.

```
def euclid_algorithm(x, y):
    return x if y == 0 else euclid_algorithm(y, x % y)
```

Algorytm rekurencyjnie zastępuje większe liczby resztą ich podziału i kończy się, gdy druga liczba staje się 0, zwracając pierwszą liczbę jako GCD.



UWAGA:

Algorytmy rekurencyjne są sexi. Ale niekeidy zachowują sie jak nimfomanka - są toksyczne. tfu pamieciozerne, może sie okazać ze skończył wam się RAM.

# 2. Głębokość Pierwsze Przemierzanie Drzewa

Na początek napiszmy drzewo binarne.

```
class BinaryTree:
    def __init__(self, value):
        self.key = value
        self.left_child = None
        self.right_child = None

    def insert_left(self, value):
        if self.left_child == None:
            self.left_child = BinaryTree(value)
        else:
            bin_tree = BinaryTree(value)
            bin_tree.left_child = self.left_child
            self.left_child = bin_tree

    def insert_right(self, value):
        if self.right_child == None:
            self.right_child = BinaryTree(value)
        else:
            bin_tree = BinaryTree(value)
            bin_tree.right_child = self.right_child
            self.right_child = bin_tree
# Creating a new Binary Tree
tree = BinaryTree(1)

tree.insert_left(2)
tree.insert_right(3)

tree.insert_left(4)
tree.left_child.insert_right(6)
tree.insert_right(5)
```

The binary tree looks like this:

```
    1
   / \
  4   5
 /     \
2       3
 \
  6 
```

Here are the elegant algorithms for traversing through this tree, depth-first.

```
#Pre-order Traversal
def preorder(tree):
    if tree:
        print(tree.key)
        preorder(tree.left_child)
        preorder(tree.right_child)
#In-order Traversal
def inorder(tree):
    if tree:
        inorder (tree.left_child)
        print(tree.key)
        inorder (tree.right_child)
#Post-order Traversal
def postorder(tree):
    if tree:
        postorder(tree.left_child)
        postorder(tree.right_child)
        print(tree.key)
```

# 3. Sito Eratostenesa

## Amateur Approach

Podejście początkującego do znajdowania liczb pierwszych do pewnego limitu N wygląda następująco.

```
# Function to check if a number is prime
def is_prime(n):
    if n <= 1:
      return False
    for i in range(2, n):
        if n % i == 0:
            return False
    return True
# Function to find primes
def find_primes(N):
    primes = []
    
    for i in range(2, N+1):
        if is_prime(i):
            primes.append(i)
    
    return primes
```

Ta funkcja wykonuje wiele niepotrzebnych kontroli i dlatego jest kosztowna obliczeniowo.

## Zajebiszaczy Algorytm

Sito Eratostenesa to stary algorytm służący do znajdowania wszystkich liczb pierwszych do podanego limitu.

Algorytm najpierw tworzy listę od 2 do podanego limitu i zaznacza wszystkie liczby jako pierwsze.

Następnie zaczynając od pierwszej liczby pierwszej 2, iteracyjnie znajduje liczby pierwsze i oznacza wielokrotności znalezionych liczb pierwszych jako inne niż pierwsze.

Proces ten trwa aż do pierwiastka kwadratowego podanej granicy.

Liczby, które pozostają nieoznaczone, są zwracane w wyniku.

```
def sieve_of_eratosthenes(limit):
    prime = [True] * (limit + 1)
    p = 2
    
    while (p * p <= limit):
        if prime[p] == True:
            for i in range(p * p, limit + 1, p):
                prime[i] = False
        p += 1
   
    prime_numbers = [p for p in range(2, limit) if prime[p]]
    
    return prime_numbers
```

# 4. Calculating Factorials

The iterative approach to finding factorials works as follows.

```
def factorial(n):
    if n == 0:
        return 1  
    
    result = 1

    for i in range(1, n + 1):
        result *= i
    
    return result
```

This method iteratively multiplies numbers from `1` up to `n` in a loop, accumulating the result.

I find the recursive approach quite elegant to code (although the approach is inefficient due to the recursive calls involved).

This is how it looks.

```
def factorial(n):
    if n == 0:
        return 1  
    else:
        return n * factorial(n-1)  
```

# 5. Generating Fibonacci Numbers

The recursive approach to generating Fibonacci numbers looks quite elegant  again! (although it is inefficient for large values of `n` due to growing recursive calls).

```
# To calculate the nth Fibonacci number
def fibonacci(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n-1) + fibonacci(n-2)
```

The iterative approach for the same looks as follows.

```
def fibonacci(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        a, b = 0, 1 
        for _ in range(2, n + 1):
            a, b = b, a + b  
        return b
```



# Hokus Pokus Czary Mary w SQL

Microsoft SQL Server to solidny relacyjny system zarządzania bazą danych, który wydajnie przechowuje i pobiera dane. Aby osiągnąć optymalną wydajność i utrzymać integralność danych, SQL Server wykorzystuje różne typy danych. W tym artykule przyjrzymy się powszechnie używanym typom danych Microsoft SQL, ich cechom i najlepszym praktykom wyboru odpowiedniego typu danych dla Twoich konkretnych potrzeb.

# 1. Character Data Types

Character data types in Microsoft SQL Server are used to store alphanumeric or text data. These types of data are necessary to store information such as names, addresses and text descriptions. SQL Server provides two main categories of character data types: fixed-length and variable-length.

## CHAR (Fixed-Length Character Data Type)

- Opis: CHAR jest typem danych znaków o stałej długości, co oznacza, że przechowuje określoną liczbę znaków dla każdej wartości, wypełniając niewykorzystaną przestrzeń pustymi znakami.
- Składnia: CHAR(n), gdzie 'n' to stała długość określona w kategoriach znaków.
- Przykład: Jeśli zadeklarujesz kolumnę jako CHAR(10) i wstawisz do niej 'John', zostanie ona przechowywana jako 'John' z dodatkowymi spacjami, aby wypełnić stałą długość.

```
-- Creating a table with a CHAR column
CREATE TABLE Employee (
    EmployeeID INT PRIMARY KEY,
    FirstName CHAR(30),
    LastName CHAR(30)
);

-- Inserting data into the table
INSERT INTO Employee (EmployeeID, FirstName, LastName)
VALUES (1, 'John', 'Doe');

-- Querying the table
SELECT * FROM Employee;
```

W tym przykładzie kolumny Imię i Nazwisko to CHAR(30), co oznacza, że zawsze będą przechowywać 30 znaków, a wszelkie niewykorzystane spacje będą wypełnione pustymi miejscami.

## VARCHAR (Variable-Length Character Data Type)

- Opis: VARCHAR to typ danych znaków o zmiennej długości, umożliwiający przechowywanie ciągów znaków o zmiennej wielkości bez końcowego wypełnienia spacji.
- Składnia: VARCHAR(n), gdzie 'n' to maksymalna długość ciągu.
- Przykład: Jeśli zadeklarujesz kolumnę jako VARCHAR(10) i wstawisz 'John', będzie ona przechowywana jako 'John' bez dodatkowych spacji.

```
-- Creating a table with a VARCHAR column
CREATE TABLE Product (
    ProductID INT PRIMARY KEY,
    ProductName VARCHAR(50)
);

-- Inserting data into the table
INSERT INTO Product (ProductID, ProductName)
VALUES (1, 'Laptop'), (2, 'Smartphone');

-- Querying the table
SELECT * FROM Product;
```

W tym przykładzie kolumna ProductName to VARCHAR(50), co oznacza, że może przechowywać ciągi o zmiennej długości do 50 znaków bez dopełnienia z pustymi miejscami.

## NCHAR i NVARCHAR (Typy danych znaków Unicode)

- Opis: NCHAR i NVARCHAR są podobne odpowiednio do CHAR i VARCHAR, ale są zaprojektowane do przechowywania znaków Unicode, zapewniając obsługę danych wielojęzycznych.
- Składnia: NCHAR(n) i NVARCHAR(n), gdzie 'n' to długość znaków.
- Przykład: NCHAR i NVARCHAR umożliwiają przechowywanie znaków z różnych języków, zapewniając szerszą obsługę języka.

```
-- Creating a table with NCHAR and NVARCHAR columns
CREATE TABLE Customer (
    CustomerID INT PRIMARY KEY,
    FirstName NCHAR(50),
    LastName NVARCHAR(50),
    Email NVARCHAR(100)
);

-- Inserting data into the table
INSERT INTO Customer (CustomerID, FirstName, LastName, Email)
VALUES
    (1, N'John', N'Doe', N'john.doe@example.com'),
    (2, N'Jane', N'Smith', N'jane.smith@example.com');

-- Querying the table
SELECT * FROM Customer;
```

W tym przykładzie:

- `FirstName` jest typu NCHAR(50), co oznacza, że jest to ciąg znaków Unicode o stałej długości, który może przechowywać do 50 znaków.
- `LastName` jest typu NVARCHAR(50), wskazując na ciąg znaków Unicode o zmiennej długości, który może również przechowywać do 50 znaków.
- `Email` jest typu NVARCHAR(100), pozwalając na ciąg znaków Unicode o zmiennej długości do 100 znaków.

Przedrostek 'N' przed literałami łańcuchowymi (np. N'John') służy do wskazania, że ciąg jest w formacie Unicode. Jest to ważne podczas pracy z kolumnami NCHAR i NVARCHAR.

Obsługa Unicode jest cenna w przypadku danych wielojęzycznych, ponieważ umożliwia przechowywanie znaków z różnych języków. Ważne jest, aby wybrać między NCHAR i NVARCHAR w oparciu o to, czy stała lub zmienna długość jest bardziej odpowiednia dla konkretnej kolumny w schemacie bazy danych.

Typy danych znaków są powszechnie używane, gdy mają do czynienia z informacjami tekstowymi w bazie danych. Wybór między stałą długością (CHAR) a zmienną długością (VARCHAR) zależy od charakteru danych. Jeśli długość danych jest stała, CHAR może być bardziej odpowiedni, podczas gdy VARCHAR jest preferowany dla danych o zmiennej długości, aby zaoszczędzić miejsce na dysku.

Ważne jest, aby wziąć pod uwagę wymagania dotyczące pamięci masowej i implikacje wydajnościowe przy wyborze typów danych znaków. Zrozumienie tych rozróżnień pomaga programistom zaprojektować wydajne i zoptymalizowane struktury baz danych dla ich aplikacji.

# 2. Numeryczne typy danych

Numeryczne typy danych w Microsoft SQL Server są używane do przechowywania wartości liczbowych, w tym liczb całkowitych i dziesiętnych. Te typy danych są niezbędne do reprezentowania różnych typów informacji liczbowych w bazie danych. SQL Server zapewnia szereg liczbowych typów danych, aby dostosować się do różnych wymagań dotyczących precyzji, skali i rozmiaru. Oto niektóre z powszechnie stosowanych typów danych liczbowych

## INT (liczba całkowita)

- Opis: INT to 32-bitowy typ danych całkowitych ze znakiem używany do przechowywania liczb całkowitych bez miejsc po przecinku.
- Zakres: -2,147,483,648 do 2,147,483,647.

```
-- Creating a table with INT column
CREATE TABLE Employee (
    EmployeeID INT PRIMARY KEY,
    FirstName NVARCHAR(50),
    LastName NVARCHAR(50),
    Age INT,
    Salary INT
);

-- Inserting data into the table
INSERT INTO Employee (EmployeeID, FirstName, LastName, Age, Salary)
VALUES
    (1, 'John', 'Doe', 30, 50000),
    (2, 'Jane', 'Smith', 25, 60000),
    (3, 'Bob', 'Johnson', 35, 75000);

-- Querying the table
SELECT * FROM Employee;
```

W tym przykładzie:

- Kolumny `Age` i Wynagrodzenie są typu INT, reprezentując wartości całkowite.
- `EmployeeID` jest ustawiony jako klucz podstawowy.

Możesz dostosować rozmiar i właściwości kolumny INT w oparciu o swoje specyficzne wymagania.

## BIGINT (Duża liczba całkowita)

- Opis: BIGINT to 64-bitowy typ danych liczb całkowitych ze znakiem, umożliwiający przechowywanie większych liczb całkowitych.
- Zakres: -9,223,372,036,854,775,808 do 9,223,372,036,854,775,807.

```
-- Creating a table with BIGINT column
CREATE TABLE Sales (
    SaleID BIGINT PRIMARY KEY,
    ProductName NVARCHAR(100),
    QuantitySold INT,
    Revenue BIGINT,
    TransactionDate DATE
);

-- Inserting data into the table
INSERT INTO Sales (SaleID, ProductName, QuantitySold, Revenue, TransactionDate)
VALUES
    (1, 'Laptop', 10, 150000, '2024-02-20'),
    (2, 'Smartphone', 20, 80000, '2024-02-21'),
    (3, 'Tablet', 15, 60000, '2024-02-22');

-- Querying the table
SELECT * FROM Sales;
```

W tym przykładzie:

- `SaleID` jest typu BIGINT, reprezentujący dużą liczbę całkowitą.
- `Revenue` jest również typu BIGINT, nadaje się do przechowywania dużych wartości liczbowych.

Możesz dostosować typy i rozmiary danych w oparciu o konkretne wymagania aplikacji. Typ danych BIGINT jest powszechnie używany w przypadku dużych liczb, które mogą przekraczać zakres typu danych INT.

## SMALLINT (Small Integer)

- Opis: SMALLINT to 16-bitowy typ danych całkowitych ze znakiem odpowiedni dla mniejszych liczb całkowitych.
- Zasięg: -32,768 do 32,767.

```
-- Creating a table with SMALLINT column
CREATE TABLE Inventory (
    ProductID INT PRIMARY KEY,
    ProductName NVARCHAR(50),
    StockQuantity SMALLINT,
    MinStock SMALLINT,
    MaxStock SMALLINT
);

-- Inserting data into the table
INSERT INTO Inventory (ProductID, ProductName, StockQuantity, MinStock, MaxStock)
VALUES
    (1, 'Laptop', 25, 10, 50),
    (2, 'Mouse', 50, 5, 100),
    (3, 'Headphones', 30, 10, 50);

-- Querying the table
SELECT * FROM Inventory;
```

- `StockQuantity`, MinStock i MaxStock są typu SMALLINT, reprezentujące małe wartości całkowite.

Typ danych SMALLINT jest odpowiedni dla scenariuszy, w których oczekuje się, że zakres wartości będzie niewielki, co pozwala na wydajne przechowywanie danych. Dostosuj typy i rozmiary danych w oparciu o konkretne wymagania aplikacji.

## TINYINT (Tiny Integer)

- Description: TINYINT is an 8-bit unsigned integer data type, representing small non-negative whole numbers.
- Range: 0 to 255.

```
-- Creating a table with TINYINT column
CREATE TABLE TemperatureData (
    SensorID INT PRIMARY KEY,
    Location NVARCHAR(50),
    CurrentTemperature TINYINT,
    MinTemperature TINYINT,
    MaxTemperature TINYINT
);

-- Inserting data into the table
INSERT INTO TemperatureData (SensorID, Location, CurrentTemperature, MinTemperature, MaxTemperature)
VALUES
    (1, 'Room A', 22, 18, 25),
    (2, 'Room B', 19, 15, 22),
    (3, 'Room C', 24, 20, 28);

-- Querying the table
SELECT * FROM TemperatureData;
```

In this example:

- `CurrentTemperature`, `MinTemperature`, and `MaxTemperature` are of type TINYINT, representing small integer values.

The `TINYINT` data type is suitable for scenarios where the range of values is  expected to be small, and you want to optimize storage by using a  smaller data type. Adjust the data types and sizes based on your  specific application requirements.

## DECIMAL and NUMERIC (Fixed-Point Decimal)

- Description: DECIMAL and NUMERIC are used for storing fixed-point decimal numbers,  where precision and scale can be specified to control the number of  digits before and after the decimal point.
- Syntax: `DECIMAL(p, s)` or `NUMERIC(p, s)`, where 'p' is the total number of digits, and 's' is the number of digits after the decimal point.

```
-- Creating a table with DECIMAL and NUMERIC columns
CREATE TABLE ProductPricing (
    ProductID INT PRIMARY KEY,
    ProductName NVARCHAR(100),
    UnitPrice DECIMAL(10, 2),
    Discount NUMERIC(5, 2),
    QuantityInStock INT
);

-- Inserting data into the table
INSERT INTO ProductPricing (ProductID, ProductName, UnitPrice, Discount, QuantityInStock)
VALUES
    (1, 'Laptop', 1200.50, 0.1, 50),
    (2, 'Smartphone', 699.99, 0.05, 100),
    (3, 'Headphones', 99.95, 0, 200);

-- Querying the table
SELECT * FROM ProductPricing;
```

In this example:

- `UnitPrice` is of type DECIMAL(10, 2), representing a fixed-point decimal with a total of 10 digits and 2 decimal places.
- `Discount` is of type NUMERIC(5, 2), similar to DECIMAL, with a total of 5 digits and 2 decimal places.

These data types are commonly used when precision is crucial, such as in  financial or pricing scenarios. The specified precision and scale in  DECIMAL and NUMERIC determine the maximum number of digits, both to the  left and right of the decimal point, that can be stored in the column.

Adjust the precision and scale based on your specific application requirements.

## FLOAT and REAL (Floating-Point)

- Description: FLOAT and REAL are used for storing floating-point numbers with approximate precision.
- FLOAT Range: -1.79E+308 to 1.79E+308.
- REAL Range: -3.40E+38 to 3.40E+38.

```
-- Creating a table with FLOAT and REAL columns
CREATE TABLE SensorData (
    SensorID INT PRIMARY KEY,
    Location NVARCHAR(50),
    Temperature FLOAT,
    Humidity REAL,
    Pressure FLOAT
);

-- Inserting data into the table
INSERT INTO SensorData (SensorID, Location, Temperature, Humidity, Pressure)
VALUES
    (1, 'Room A', 22.5, 45.3, 1013.2),
    (2, 'Room B', 19.8, 50.1, 1012.5),
    (3, 'Room C', 24.2, 42.7, 1014.0);

-- Querying the table
SELECT * FROM SensorData;
```

In this example:

- `Temperature` is of type FLOAT, representing a floating-point number.
- `Humidity` is of type REAL, also representing a floating-point number with less precision than FLOAT.
- `Pressure` is again of type FLOAT.

The `FLOAT` and `REAL` data types are suitable for scenarios where you need to represent  numbers with a fractional component and a wide range of possible values. However, it's essential to note that `FLOAT` has higher precision compared to `REAL`. Adjust the data types based on your specific application requirements and the precision you need.

Numeric data types are crucial for accurately representing and manipulating  numerical values in a SQL Server database. When choosing a numeric data  type, consider the range and precision needed for the specific data  being stored. Using the appropriate numeric data type helps optimize  storage space and ensures accurate calculations in database operations.

# 3. Date and Time Data Types

Microsoft SQL Server provides a range of date and time data types to store and  manage temporal information efficiently. These data types enable the  representation of dates, times, and combinations of both. Here are the  primary date and time data types in SQL Server

## DATE

- Description: The DATE data type is used to store dates without a time component.
- Format: YYYY-MM-DD.
- Example: ‘2024–02–20’.

```
-- Creating a table with DATE column
CREATE TABLE EventSchedule (
    EventID INT PRIMARY KEY,
    EventName NVARCHAR(100),
    EventDate DATE,
    Location NVARCHAR(50)
);

-- Inserting data into the table
INSERT INTO EventSchedule (EventID, EventName, EventDate, Location)
VALUES
    (1, 'Conference', '2024-05-15', 'Convention Center'),
    (2, 'Workshop', '2024-06-10', 'Training Room'),
    (3, 'Networking Event', '2024-07-20', 'Rooftop Lounge');

-- Querying the table
SELECT * FROM EventSchedule;
```

In this example:

- `EventDate` is of type DATE, representing a date without a time component.

The `DATE` data type is commonly used when you need to store and query date  information without considering the time. Adjust the column size and  properties based on your specific application requirements.

## TIME

- Description: The TIME data type stores time values without a date component.
- Format: HH:MM:SS.sss, where ‘sss’ represents fractional seconds.
- Example: ‘12:30:45.500’.

```
-- Creating a table with TIME column
CREATE TABLE Appointment (
    AppointmentID INT PRIMARY KEY,
    ClientName NVARCHAR(100),
    AppointmentTime TIME,
    AppointmentDuration INT -- Assuming duration is in minutes
);

-- Inserting data into the table
INSERT INTO Appointment (AppointmentID, ClientName, AppointmentTime, AppointmentDuration)
VALUES
    (1, 'John Doe', '10:30:00', 60),
    (2, 'Jane Smith', '14:00:00', 45),
    (3, 'Bob Johnson', '16:45:00', 30);

-- Querying the table
SELECT * FROM Appointment;
```

In this example:

- `AppointmentTime` is of type TIME, representing a time without a date component.

The `TIME` data type is useful when you need to store and query time information  without considering the date. Adjust the column size and properties  based on your specific application requirements. Additionally, the `AppointmentDuration` column is included to demonstrate a scenario where you might store the  duration of an appointment in minutes. Adjust this column based on your  specific use case.

## DATETIME

- Description: The DATETIME data type stores both date and time information.
- Format: YYYY-MM-DD HH:MM:SS.sss, where ‘sss’ represents fractional seconds.
- Example: ‘2024–02–20 12:30:45.500’.

```
-- Creating a table with DATETIME column
CREATE TABLE EventLog (
    LogID INT PRIMARY KEY,
    EventName NVARCHAR(100),
    LogDateTime DATETIME,
    LogDetails NVARCHAR(MAX)
);

-- Inserting data into the table
INSERT INTO EventLog (LogID, EventName, LogDateTime, LogDetails)
VALUES
    (1, 'System Start', '2024-03-01 08:00:00', 'System started successfully.'),
    (2, 'User Login', '2024-03-01 08:15:30', 'User John logged in.'),
    (3, 'Data Update', '2024-03-01 09:45:20', 'Updated records in the database.');

-- Querying the table
SELECT * FROM EventLog;
```

In this example:

- `LogDateTime` is of type DATETIME, representing both date and time.

The `DATETIME` data type is commonly used when you need to store and query information that includes both date and time components. Adjust the column size and properties based on your specific application requirements. Note that  in more recent versions of SQL Server, you might also consider using the `DATETIME2` data type, which provides higher fractional seconds precision and an extended date range compared to `DATETIME`.

## SMALLDATETIME

- Description: Similar to DATETIME but with a reduced precision, allowing for a smaller storage size.
- Format: YYYY-MM-DD HH:MM.
- Example: ‘2024–02–20 12:30’.

```
-- Creating a table with SMALLDATETIME column
CREATE TABLE MeetingSchedule (
    MeetingID INT PRIMARY KEY,
    MeetingName NVARCHAR(100),
    MeetingDateTime SMALLDATETIME,
    MeetingLocation NVARCHAR(50)
);

-- Inserting data into the table
INSERT INTO MeetingSchedule (MeetingID, MeetingName, MeetingDateTime, MeetingLocation)
VALUES
    (1, 'Team Meeting', '2024-04-15 09:30:00', 'Conference Room A'),
    (2, 'Project Review', '2024-05-02 14:00:00', 'Meeting Room B'),
    (3, 'Training Session', '2024-06-10 10:00:00', 'Training Room');

-- Querying the table
SELECT * FROM MeetingSchedule;
```

In this example:

- `MeetingDateTime` is of type SMALLDATETIME, representing both date and time but with a reduced precision compared to DATETIME.

The `SMALLDATETIME` data type is suitable when you need to store date and time information  with less precision than DATETIME, which can help save storage space.  Adjust the column size and properties based on your specific application requirements.

## DATETIME2

- Description: An extension of DATETIME with higher fractional seconds precision, providing microsecond accuracy.
- Format: YYYY-MM-DD HH:MM:SS.ssssss.
- Example: ‘2024–02–20 12:30:45.123456’.

```
-- Creating a table with DATETIME2 column
CREATE TABLE OrderHistory (
    OrderID INT PRIMARY KEY,
    CustomerName NVARCHAR(100),
    OrderDateTime DATETIME2,
    TotalAmount DECIMAL(18, 2)
);

-- Inserting data into the table
INSERT INTO OrderHistory (OrderID, CustomerName, OrderDateTime, TotalAmount)
VALUES
    (1, 'John Doe', '2024-02-25 12:30:00.1234567', 150.75),
    (2, 'Jane Smith', '2024-02-26 15:45:30.9876543', 220.50),
    (3, 'Bob Johnson', '2024-02-27 09:15:45.3456789', 75.25);

-- Querying the table
SELECT * FROM OrderHistory;
```

In this example:

- `OrderDateTime` is of type DATETIME2, representing both date and time with higher fractional seconds precision compared to DATETIME.

Choose the appropriate data type based on your precision and storage requirements. `DATETIME2` is often recommended for new applications due to its extended range and precision. Adjust the column sizes and properties based on your  specific application needs.

## DATETIMEOFFSET

- Description: Combines DATETIME2 with a time zone offset, allowing for storage of  date and time values with awareness of time zone differences.
- Format: YYYY-MM-DD HH:MM:SS.ssssss OFFSET ±hh:mm.
- Example: ‘2024–02–20 12:30:45.123456 -05:00’.

```
-- Creating a table with DATETIMEOFFSET column
CREATE TABLE FlightSchedule (
    FlightID INT PRIMARY KEY,
    FlightNumber NVARCHAR(20),
    DepartureAirport NVARCHAR(50),
    DepartureDateTime DATETIMEOFFSET,
    ArrivalAirport NVARCHAR(50),
    ArrivalDateTime DATETIMEOFFSET
);

-- Inserting data into the table
INSERT INTO FlightSchedule (FlightID, FlightNumber, DepartureAirport, DepartureDateTime, ArrivalAirport, ArrivalDateTime)
VALUES
    (1, 'FL123', 'Airport A', '2024-04-15T10:30:00.0000000-05:00', 'Airport B', '2024-04-15T13:45:00.0000000-05:00'),
    (2, 'FL456', 'Airport C', '2024-04-20T15:15:00.0000000+02:00', 'Airport D', '2024-04-20T18:30:00.0000000+02:00'),
    (3, 'FL789', 'Airport E', '2024-04-25T08:45:00.0000000-08:00', 'Airport F', '2024-04-25T11:00:00.0000000-08:00');

-- Querying the table
SELECT * FROM FlightSchedule;
```

In this example:

- `DepartureDateTime` and `ArrivalDateTime` are of type `DATETIMEOFFSET`, representing date and time with timezone offset information.

The `DATETIMEOFFSET` data type is useful when you need to store date and time information  along with the timezone. This is particularly important in scenarios  where time zone differences are significant, such as in international  flight schedules.

Adjust the column sizes and properties based on your specific application requirements.

These data types play a crucial role in applications where precise tracking  of dates and times is necessary, such as scheduling, logging, and event  tracking. It’s important to choose the appropriate data type based on  the level of precision and the specific requirements of the application.

When designing a database schema, selecting the right date and time data  type ensures accurate storage and retrieval of temporal information,  while also facilitating efficient querying and manipulation of  date-related data.

# 4. Binary Data Types

Binary data types in Microsoft SQL Server are designed to store binary data,  which includes sequences of raw bytes. These data types are used to  store non-textual and variable-length information such as images, audio  files, and other binary data. SQL Server provides several binary data  types to accommodate different storage needs:

## BINARY

- Description: The BINARY data type is used to store fixed-length binary data.
- Syntax: `BINARY(n)`, where 'n' is the fixed length specified in bytes.
- Example: `BINARY(10)` would store a fixed-length binary value of 10 bytes.

```
-- Creating a table with BINARY column
CREATE TABLE EmployeePhotos (
    EmployeeID INT PRIMARY KEY,
    FirstName NVARCHAR(50),
    LastName NVARCHAR(50),
    Photo BINARY(8000) -- Adjust the size based on the maximum expected size of a photo
);

-- Inserting data into the table
INSERT INTO EmployeePhotos (EmployeeID, FirstName, LastName, Photo)
VALUES
    (1, 'John', 'Doe', 0x<BinaryData1>), -- Replace <BinaryData1> with the actual binary data for the photo
    (2, 'Jane', 'Smith', 0x<BinaryData2>), -- Replace <BinaryData2> with the actual binary data for the photo
    (3, 'Bob', 'Johnson', 0x<BinaryData3>); -- Replace <BinaryData3> with the actual binary data for the photo

-- Querying the table
SELECT * FROM EmployeePhotos;
```

In this example:

- `Photo` is of type `BINARY(100000)`, indicating a fixed-length binary data type with a maximum size of  100,000 bytes. Adjust the size based on the maximum expected size of a  photo.

The `BINARY` data type is used to store fixed-length binary data. It's commonly used for scenarios where the size of the binary data is known and  consistent, such as storing images, documents, or other binary files.

Replace `<BinaryData1>`, `<BinaryData2>`, and `<BinaryData3>` with the actual binary data for the respective photos when inserting data.

Adjust the column sizes and properties based on your specific application requirements.

## VARBINARY

- Description: The VARBINARY data type is used to store variable-length binary data.
- Syntax: `VARBINARY(n)`, where 'n' is the maximum length specified in bytes.
- Example: `VARBINARY(100)` would store a variable-length binary value with a maximum length of 100 bytes.

```
-- Creating a table with VARBINARY column
CREATE TABLE ProductImages (
    ProductID INT PRIMARY KEY,
    ProductName NVARCHAR(50),
    Image VARBINARY(MAX) -- Adjust the size based on the maximum expected size of an image
);

-- Inserting data into the table
INSERT INTO ProductImages (ProductID, ProductName, Image)
VALUES
    (1, 'Laptop', 0x<BinaryData1>), -- Replace <BinaryData1> with the actual binary data for the image
    (2, 'Smartphone', 0x<BinaryData2>), -- Replace <BinaryData2> with the actual binary data for the image
    (3, 'Headphones', 0x<BinaryData3>); -- Replace <BinaryData3> with the actual binary data for the image

-- Querying the table
SELECT * FROM ProductImages;
```

In this example:

- `Image` is of type `VARBINARY(MAX)`, indicating a variable-length binary data type with a maximum size of  2^31-1 bytes (essentially unlimited). Adjust the size based on the  maximum expected size of an image.

The `VARBINARY` data type is suitable for storing variable-length binary data, such as  images, documents, or other binary files where the size may vary.

Replace `<BinaryData1>`, `<BinaryData2>`, and `<BinaryData3>` with the actual binary data for the respective images when inserting data.

Adjust the column sizes and properties based on your specific application requirements.

## IMAGE

- Description: The IMAGE data type is deprecated in newer versions of SQL Server  (starting from SQL Server 2005) and is replaced by VARBINARY(MAX).
- Example: `IMAGE` used to store variable-length binary data with a maximum size of 2^31-1 bytes.

The `IMAGE` data type has been deprecated in SQL Server, starting from SQL Server 2005. It's recommended to use `VARBINARY(MAX)` instead. However, if you're working with an older system that still uses `IMAGE`, here's an example:

```
-- Creating a table with IMAGE column (deprecated, use VARBINARY(MAX) instead)
CREATE TABLE LegacyImages (
    ImageID INT PRIMARY KEY,
    ImageDescription NVARCHAR(100),
    ImageData IMAGE
);

-- Inserting data into the table
INSERT INTO LegacyImages (ImageID, ImageDescription, ImageData)
VALUES
    (1, 'Old Photo', 0x<BinaryData1>), -- Replace <BinaryData1> with the actual binary data for the image
    (2, 'Historical Document', 0x<BinaryData2>), -- Replace <BinaryData2> with the actual binary data for the image
    (3, 'Antique Map', 0x<BinaryData3>); -- Replace <BinaryData3> with the actual binary data for the image

-- Querying the table
SELECT * FROM LegacyImages;
```

In this example:

- `ImageData` is of type `IMAGE`, which is deprecated.

It’s highly recommended to migrate to the more modern `VARBINARY(MAX)` data type. If possible, update your schema and queries to use `VARBINARY(MAX)` instead of `IMAGE` for better compatibility with newer SQL Server versions.

Replace `<BinaryData1>`, `<BinaryData2>`, and `<BinaryData3>` with the actual binary data for the respective images when inserting  data. Adjust the column sizes and properties based on your specific  application requirements.

Binary data types are essential for handling non-textual data efficiently.  When choosing between BINARY and VARBINARY, consider whether the binary  data has a fixed or variable length. The use of VARBINARY(MAX) is  preferred for storing larger binary objects where the size may vary.

When working with binary data types, it’s crucial to handle encoding and  decoding appropriately in your applications to ensure the accurate  storage and retrieval of binary information. These data types are  particularly valuable in scenarios where files or multimedia content  need to be stored within the database.

# 5. Miscellaneous Data Types

In Microsoft SQL Server, miscellaneous data types refer to a category of  data types that don’t fit neatly into the common categories like  character, numeric, date and time, or binary. These data types serve  specific purposes and are used for unique scenarios. Here are some of  the miscellaneous data types in SQL Server:

## UNIQUEIDENTIFIER

- Description: The UNIQUEIDENTIFIER data type is used to store globally unique  identifiers (GUIDs). These are 128-bit values typically represented as a sequence of 32 hexadecimal characters.
- Example: `0E984725-C51C-4BF5-96B1-ED28AFC9A23E`.

```
-- Creating a table with UNIQUEIDENTIFIER column
CREATE TABLE EmployeeGuids (
    EmployeeID UNIQUEIDENTIFIER PRIMARY KEY,
    FirstName NVARCHAR(50),
    LastName NVARCHAR(50),
    BirthDate DATE
);

-- Inserting data into the table
INSERT INTO EmployeeGuids (EmployeeID, FirstName, LastName, BirthDate)
VALUES
    (NEWID(), 'John', 'Doe', '1990-05-15'),
    (NEWID(), 'Jane', 'Smith', '1985-08-20'),
    (NEWID(), 'Bob', 'Johnson', '1995-02-10');

-- Querying the table
SELECT * FROM EmployeeGuids;
```

In this example:

- `EmployeeID` is of type `UNIQUEIDENTIFIER`, representing a globally unique identifier.
- `NEWID()` function is used to generate a new unique identifier for each row during insertion.

The `UNIQUEIDENTIFIER` data type is often used to store unique identifiers, such as primary  key values, where the uniqueness across tables or systems is essential.

## XML

- Description: The XML data type is used to store XML (eXtensible Markup Language)  data. It allows for the storage of well-formed XML documents.
- Example: `<person><name>John Doe</name><age>30</age></person>`.

```
-- Creating a table with XML column
CREATE TABLE ProductCatalog (
    ProductID INT PRIMARY KEY,
    ProductName NVARCHAR(100),
    ProductDetails XML
);

-- Inserting data into the table with XML values
INSERT INTO ProductCatalog (ProductID, ProductName, ProductDetails)
VALUES
    (1, 'Laptop', '<Product><Brand>Dell</Brand><Price>1200.50</Price><Category>Laptops</Category></Product>'),
    (2, 'Smartphone', '<Product><Brand>Apple</Brand><Price>699.99</Price><Category>Smartphones</Category></Product>'),
    (3, 'Headphones', '<Product><Brand>Sony</Brand><Price>99.95</Price><Category>Audio</Category></Product>');

-- Querying the table
SELECT * FROM ProductCatalog;
```

In this example:

- `ProductDetails` is of type `XML`, representing XML data.

The `XML` data type is used to store XML documents or fragments in SQL Server. It allows you to store and query XML data directly within the database.

Adjust the column sizes and properties based on your specific application  requirements. When working with XML data, you can use various XML  functions and methods in SQL Server to query and manipulate the XML  content.

Adjust the column sizes and properties based on your specific application  requirements. Keep in mind that using specific data types whenever  possible is generally preferred over using `SQL_VARIANT` for better data integrity and query performance.

## ROWVERSION (TIMESTAMP in versions prior to SQL Server 2008)

- Description: ROWVERSION is a data type used for versioning and is automatically  updated every time a row is modified. It’s often used for optimistic  concurrency control.
- Example: `0x00000000000007D2`.

```
-- Creating a table with ROWVERSION column
CREATE TABLE EmployeeData (
    EmployeeID INT PRIMARY KEY,
    FirstName NVARCHAR(50),
    LastName NVARCHAR(50),
    VersionStamp ROWVERSION
);

-- Inserting data into the table
INSERT INTO EmployeeData (EmployeeID, FirstName, LastName)
VALUES
    (1, 'John', 'Doe'),
    (2, 'Jane', 'Smith'),
    (3, 'Bob', 'Johnson');

-- Querying the table
SELECT * FROM EmployeeData;
```

In this example:

- `VersionStamp` is of type `ROWVERSION`.

The `ROWVERSION` data type is automatically updated by SQL Server whenever a row is  inserted or updated. It's often used for detecting changes to a row,  especially in scenarios where multiple users might be updating the same  data.

Adjust the column sizes and properties based on your specific application requirements. Note that there can be only one `ROWVERSION` column per table.

## TABLE

- Description: The TABLE data type is used in stored procedures to define a table  structure. It is particularly useful for passing a result set or a  table-valued parameter to a stored procedure or a function.
- Example: `DECLARE @MyTable TABLE (ID INT, Name NVARCHAR(50))`.

These miscellaneous data types cater to specific needs in database design and application development. The UNIQUEIDENTIFIER is commonly used for  primary keys, XML for storing structured document data, SQL_VARIANT for  handling different data types in a single column, ROWVERSION for  concurrency control, and TABLE for working with table-valued parameters. Understanding and appropriately using these data types contribute to  the flexibility and functionality of a SQL Server database.

# 6. Spatial Data Types

Spatial data types in Microsoft SQL Server are designed to represent and manage geometric and geographic data. These data types enable the storage and  manipulation of spatial information, making SQL Server a powerful  platform for applications that involve mapping, location-based services, and spatial analysis. Here are some of the key spatial data types in  SQL Server:

## GEOMETRY

- Description: The GEOMETRY data type is used to represent planar, or flat-earth,  spatial data. It can store points, lines, and polygons in  two-dimensional space.
- Example: `POINT(1 2)`, `LINESTRING(1 2, 3 4)`, `POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))`.

```
-- Creating a table with GEOMETRY column
CREATE TABLE SpatialData (
    LocationID INT PRIMARY KEY,
    LocationName NVARCHAR(100),
    GeoLocation GEOMETRY
);

-- Inserting data into the table
INSERT INTO SpatialData (LocationID, LocationName, GeoLocation)
VALUES
    (1, 'City Park', geometry::Point(47.6205, -122.3493, 4326)),
    (2, 'Shopping Mall', geometry::Point(47.6097, -122.3331, 4326)),
    (3, 'Mountain Peak', geometry::Point(47.4914, -121.6246, 4326));

-- Querying the table
SELECT * FROM SpatialData;
```

In this example:

- `GeoLocation` is of type `GEOMETRY`.
- The `geometry::Point()` function is used to create point geometries with specified latitude, longitude, and spatial reference ID (SRID) values.

The `GEOMETRY` data type allows you to store various spatial data types, including  points, lines, and polygons. You can perform spatial operations and  queries on this data.

Adjust the column sizes and properties based on your specific application  requirements. The example uses point geometries, but you can also use  other geometry types like `LINESTRING` or `POLYGON` depending on your needs.

## GEOGRAPHY

- Description: The GEOGRAPHY data type is designed for storing ellipsoidal, or  round-earth, spatial data. It is suitable for representing points,  lines, and polygons on the Earth’s surface.
- Example: `POINT(-122.34900 47.65100)`, `LINESTRING(-122.34900 47.65100, -122.35000 47.65200)`, `POLYGON((-122.34900 47.65100, -122.35000 47.65100, -122.35000 47.65200, -122.34900 47.65200, -122.34900 47.65100))`.

```
-- Creating a table with GEOGRAPHY column
CREATE TABLE GeographicalData (
    LocationID INT PRIMARY KEY,
    LocationName NVARCHAR(100),
    GeoLocation GEOGRAPHY
);

-- Inserting data into the table
INSERT INTO GeographicalData (LocationID, LocationName, GeoLocation)
VALUES
    (1, 'City A', geography::Point(47.6205, -122.3493, 4326)),
    (2, 'City B', geography::Point(34.0522, -118.2437, 4326)),
    (3, 'City C', geography::Point(40.7128, -74.0060, 4326));

-- Querying the table
SELECT * FROM GeographicalData;
```

In this example:

- `GeoLocation` is of type `GEOGRAPHY`.
- The `geography::Point()` function is used to create point geometries with specified latitude, longitude, and spatial reference ID (SRID) values.

The `GEOGRAPHY` data type allows you to store geographical data, and you can perform spatial operations and queries on this data.

Adjust the column sizes and properties based on your specific application  requirements. The example uses point geometries, but you can also use  other geography types like `LINESTRING` or `POLYGON` depending on your needs.

## SPATIAL INDEX

- Description: While not a data type itself, a spatial index is crucial for optimizing spatial queries. It enhances the performance of spatial operations by  organizing data in a way that accelerates spatial searches.
- Usage: Creating a spatial index on a column of type GEOMETRY or GEOGRAPHY.

Spatial data types and operations enable applications to perform various  spatial analyses, such as calculating distances between points,  determining whether one spatial object intersects with another, or  finding the nearest neighbor. These capabilities are valuable in fields  like geographic information systems (GIS), logistics, and location-based services.

When working with spatial data in SQL Server, it’s important to choose the  appropriate data type (GEOMETRY or GEOGRAPHY) based on the nature of the data and the specific requirements of the application. Additionally,  leveraging spatial indexes can significantly improve the performance of  spatial queries in large datasets.

# 7. Conclusion

Understanding Microsoft SQL Server data types is essential for building efficient and well-organized databases. By selecting the appropriate data type for  each column, developers can optimize storage space, enhance query  performance, and ensure data integrity. Whether dealing with character,  numeric, date and time, binary, or specialized spatial data, a solid  grasp of SQL Server data types is a fundamental skill for any database  professional.
